<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cyc的博客 | cyc的博客</title><meta name="author" content="→╋ぁ陈ぁ╋←"><meta name="copyright" content="→╋ぁ陈ぁ╋←"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="go语言学习实用代码案例1.	随机数生成示例代码如下： 12345678910import (	&quot;math&#x2F;rand&quot;	&quot;time&quot;)func main () &amp;#123;	rand.Seed(time.Now().Unix())			&#x2F;&#x2F;time.Now().Unix() : 返回一个从1970:01:01的0时0分到现在的秒数	n :&#x3D; rand.Int">
<meta property="og:type" content="article">
<meta property="og:title" content="cyc的博客">
<meta property="og:url" content="http://example.com/2023/09/13/go%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="cyc的博客">
<meta property="og:description" content="go语言学习实用代码案例1.	随机数生成示例代码如下： 12345678910import (	&quot;math&#x2F;rand&quot;	&quot;time&quot;)func main () &amp;#123;	rand.Seed(time.Now().Unix())			&#x2F;&#x2F;time.Now().Unix() : 返回一个从1970:01:01的0时0分到现在的秒数	n :&#x3D; rand.Int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1.jpg">
<meta property="article:published_time" content="2023-09-13T13:17:28.029Z">
<meta property="article:modified_time" content="2023-10-10T07:15:10.167Z">
<meta property="article:author" content="→╋ぁ陈ぁ╋←">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/1.jpg"><link rel="shortcut icon" href="/img/1.jpg"><link rel="canonical" href="http://example.com/2023/09/13/go%E8%AF%AD%E8%A8%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cyc的博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-10 15:15:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=1371414071,3710601700&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/" title="cyc的博客"><span class="site-name">cyc的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-13T13:17:28.029Z" title="发表于 2023-09-13 21:17:28">2023-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-10T07:15:10.167Z" title="更新于 2023-10-10 15:15:10">2023-10-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="go语言学习"><a href="#go语言学习" class="headerlink" title="go语言学习"></a><strong>go语言学习</strong></h1><h2 id="实用代码案例"><a href="#实用代码案例" class="headerlink" title="实用代码案例"></a>实用代码案例</h2><h3 id="1-随机数生成"><a href="#1-随机数生成" class="headerlink" title="1.	随机数生成"></a>1.	随机数生成</h3><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">	rand.Seed(time.Now().Unix())		</span><br><span class="line">	//time.Now().Unix() : 返回一个从1970:01:01的0时0分到现在的秒数</span><br><span class="line">	n := rand.Intn(100) + 1  //生成[0,100)的整数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第一章-go文件大致模板"><a href="#第一章-go文件大致模板" class="headerlink" title="第一章 go文件大致模板"></a>第一章 go文件大致模板</h2><p>对于每一个.go的文件，首先声明该文件属于那个包（一个包就是一个文件夹），然后引入包，然后声明main函数，</p>
<p>模板示例：<strong>（每行后不需要分号）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;hello,world!&quot;)</span><br><span class="line"></span><br><span class="line">  var i0, i1, i2 int</span><br><span class="line"></span><br><span class="line">  i0 = 0</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;i&quot;,i0,i1,i2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第二章-变量"><a href="#第二章-变量" class="headerlink" title="第二章 变量"></a><strong>第二章 变量</strong></h2><p><strong>声明变量</strong>：var n 或者	var n int (声明变量n时，明确其数据类型为int类型)  还可以用 n :&#x3D; 1 相当于（var n int  和  n &#x3D; 1  两条语句，不能在全局变量时使用。）</p>
<p><strong>注意：变量声明了未使用会编译不通过！！！</strong></p>
<p>var str1 &#x3D; “你好”</p>
<p>var str2 &#x3D; “世界”</p>
<p>var str3 &#x3D; str1+str2</p>
<p><strong>注意：go语言中“+”可以用来字符串拼接，但只限于字符串与字符串之间。</strong></p>
<h3 id="查看变量占用的字节大小和数据类型"><a href="#查看变量占用的字节大小和数据类型" class="headerlink" title="查看变量占用的字节大小和数据类型"></a>查看变量占用的字节大小和数据类型</h3><p>fmt.Printf(“n1的数据类型为 <strong>%T</strong> ,n1的字节大小为 %d”,n1,<strong>unsafe.Sizeof(n1)</strong>)</p>
<p>需要引入一个包：<strong>import “unsafe”</strong></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ol>
<li>golang中没有专门的字符类型，如果要存储单个字符，一般用byte。如果保存的字符对应Unicode大于255，可以考虑用int类型保存。</li>
<li>go的字符串是由单个<strong>字节</strong>连接起来的</li>
<li>在go中字符本质是一个整数，直接输出时，是该字符对应的utf-8编码的值。必须要用格式化输出。</li>
<li>可以给变量赋一个数字，然后格式化输出时用%c,会输出该数字对应的Unicode字符</li>
<li>字符类型可以进行运算，就是对应整数的运算</li>
<li>%v 按照变量的值输出</li>
</ol>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ol>
<li>字符串一旦赋值，就不能修改</li>
<li>不同数据类型之间必须显示转换。例如： n1 &#x3D; int(n2)。大转小可能会溢出</li>
</ol>
<h3 id="基本数据类型与string类型的互相转换"><a href="#基本数据类型与string类型的互相转换" class="headerlink" title="基本数据类型与string类型的互相转换"></a>基本数据类型与string类型的互相转换</h3><ol>
<li>基本转string ： n1 &#x3D; fmt.Spintf(“%d”,n2)  。 相当于将n2格式化输出到n1里。%v 表示输出对应的值，%q表示输出的值加上双引号</li>
<li>string转基本 ：<ol>
<li>转成int64 ： n1,_&#x3D; strconv.ParseInt(str2，10，64)    10表示10进制，64表示int64</li>
<li>转成float ： f1,_ &#x3D; strconv.ParseFloat(str3，64)  64表示float64</li>
<li>转成bool： b , _ &#x3D; strconv.ParseBool(str)  </li>
<li>strconv.ParseBool(str)函数会返回两个值(value bool, err error)因为我只想获取到 value bool ,不想获取err所以我使用_忽略。</li>
</ol>
</li>
</ol>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ol>
<li><p>基本数据类型，变量存的就是值，也叫值类型</p>
</li>
<li><p>获取变量的地址，用&amp;，比如:var num int,获取num的地址: &amp;num</p>
</li>
<li><p>指针类型,，变量存的是一个地址，这个地址指向的空间存的才是值比如: var ptr *int &#x3D; &amp;num</p>
</li>
<li><p>*获取指针类型所指向的值，使用:*，比如: var <em>ptr int,使用</em>ptr获取p指向的</p>
</li>
<li><p>示例：</p>
<p>var num int &#x3D; 9<br>fmt.Printf( “num address&#x3D;%vin”,&amp;num)<br>var ptr *int<br>ptr &#x3D; &amp;num<br>*ptr &#x3D; 10&#x2F;&#x2F;这里修改时，会到num的值变化fmt.Print1n( “num &#x3D;”, num)</p>
</li>
</ol>
<h3 id="常见的值类型和引用类型"><a href="#常见的值类型和引用类型" class="headerlink" title="常见的值类型和引用类型"></a>常见的值类型和引用类型</h3><ol>
<li>值类型:基本数据类型int系列, float系列, bool, string 、<br>数组和结构体struct</li>
<li>引用类型:指针、slice切片、map、管道chan、interface 等都是引用类型</li>
<li>引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</li>
</ol>
<h2 id="第三章-标识符命名注意事项"><a href="#第三章-标识符命名注意事项" class="headerlink" title="第三章 标识符命名注意事项"></a>第三章 标识符命名注意事项</h2><ol>
<li>包名: 保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库不要冲突</li>
<li>变量名、函数名、常量名:采用驼峰法。</li>
<li>如果变量名、函数名、常量名首字母大写，则可以被其他的包访问﹔如果首字母小写，则只能在本包中使用(注:可以简单的理解成，首字母大写是公有的，首字母小写是私有的)</li>
</ol>
<h2 id="第四章-运算符"><a href="#第四章-运算符" class="headerlink" title="第四章 运算符"></a>第四章 运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ol>
<li>整数相除不会保留小数，也不会四舍五入。</li>
<li>看一个公式a % b &#x3D; a - a&#x2F; b* b</li>
</ol>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol>
<li>短路与和短路或：&amp;&amp; 、 ||</li>
</ol>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>有两个变量，a和b，要求将其进行交换，但是不允许使用中间变量，最终打印结果</p>
<p>var a int &#x3D; 10<br>var b int &#x3D; 20<br>a &#x3D; a + b &#x2F;&#x2F;<br>b &#x3D; a - b &#x2F;&#x2F; b&#x3D; a + b - b &#x3D;&#x3D;&gt; b &#x3D; a</p>
<p>a &#x3D; a - b&#x2F;&#x2F; a&#x3D; a+ b - a&#x3D;&#x3D;&gt; a &#x3D; b</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>按位与： &amp; ；按位或：| ；按位异或：^ ; 左移：&gt;&gt; ；右移：&lt;&lt; ;</p>
<h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p>大致的顺序整理</p>
<ol>
<li>括号，++，–</li>
<li>单目运算</li>
<li>算术运算符</li>
<li>移位运算</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>逗号</li>
</ol>
<h3 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h3><p>步骤：</p>
<ol>
<li>导入fmt包</li>
<li>调用fmt包的 fmt.Scanln()或者fmt.Scanf()</li>
</ol>
<p>示例：</p>
<ol>
<li>fmt.Println(“请输入年龄”)        fmt.Scanln(&amp;age)</li>
<li>fmt.Println(“请输入你的姓名，年龄，薪水，是否通过考试,使用空格隔开”)         fmt.Scanf(“%s %d %f %t”,&amp;name,&amp;age,&amp;sal，&amp;isPass)</li>
</ol>
<h2 id="第五章-流程控制"><a href="#第五章-流程控制" class="headerlink" title="第五章 流程控制"></a>第五章 流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>基本用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age&gt;<span class="number">18</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;年龄大于18&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age&lt;<span class="number">18</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;年龄小于18&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;年龄等于18&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>else不能换行</strong></p>
<p>golang支持在if中,直接定义一个变量，比如下面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age := <span class="number">20</span>; age &gt; <span class="number">18</span> &#123;</span><br><span class="line">	fmt.Println(”你年龄大于<span class="number">18</span>,要对自己的行为负责!<span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>基本用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> key &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">		fmt.Print1n(”周一,猴子穿新衣<span class="string">&quot;)</span></span><br><span class="line"><span class="string">	case &#x27;b&#x27; , &#x27;bb&#x27; :</span></span><br><span class="line"><span class="string">		fmt.Print1n(&quot;</span>周二，猴子当小二<span class="string">&quot;)</span></span><br><span class="line"><span class="string">	case &#x27;c&#x27;:</span></span><br><span class="line"><span class="string">		fmt.Print1n(&quot;</span>周三,猴子爬雪山<span class="string">&quot;)</span></span><br><span class="line"><span class="string">	default:</span></span><br><span class="line"><span class="string">		fmt.Print1n(&quot;</span>输入有误..<span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>case后是一个表达式(即:常量值、变量、一个有返回值的函数等都可以)</li>
<li>case后的各个表达式的值的数据类型，必须和 switch的表达式<strong>数据类型一致</strong></li>
<li>case后面<strong>可以带多个表达式，使用逗号间隔。</strong>比如case表达式1,表达式2…</li>
<li>case后面的表达式如果是常量值(字面量)，则要求不能重复</li>
<li>case后面不需要带break，程序匹配到一个case后就会执行对应的代码块，然后退出switch，如果一个都匹配不到，则执行default</li>
<li>default语句不是必须的.</li>
<li>switch后也可以不带表达式，类似 if –else分支来使用。如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch &#123;</span><br><span class="line">	case age == 10 :</span><br><span class="line">		fmt.Print1n( &quot;age == 10&quot;)</span><br><span class="line">	case age == 20 :</span><br><span class="line">		fmt.Print1n( &quot;age == 20&quot;)</span><br><span class="line">	default :</span><br><span class="line">		fmt.Print1n(&quot;没有匹配到&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>switch后也可以直接声明&#x2F;定义一个变量，分号结束，不推荐。</li>
<li>switch穿透-fallthrough，如果在case语句块后增加fallthrough ,则会继续执行下一个case,也叫switch穿透。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//switch的穿透fallthroughtvar num int = 10</span><br><span class="line">switch num &#123;</span><br><span class="line">	case 10:</span><br><span class="line">		fmt.Print1n( &quot;ok1&quot;)</span><br><span class="line">		fallthrough//默认只能穿透一层</span><br><span class="line">	case 20:</span><br><span class="line">		fmt.Print1n( &quot;ok2&quot;)</span><br><span class="line">		fallthrough</span><br><span class="line">	case 3o:</span><br><span class="line">		fmt.Print1n(&quot;ok3&quot;)</span><br><span class="line">	default:</span><br><span class="line">		fmt.Print1n(&quot;没有匹配到..&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>基本用法（与C差不多，可以省略小括号）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i=1;i&lt;10;i++ &#123;</span><br><span class="line">	fmt.Print1n(&quot;没有匹配到..&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>循环条件是返回一个布尔值的表达式</li>
<li>for循环的第二种使用方式<br>for 循环判断条件 {<br>   &#x2F;&#x2F;循环执行语句<br>}<br>将变量初始化和变量迭代写到其它位置</li>
<li>for循环的第三种使用方式<br>for {<br>&#x2F;&#x2F;循环执行语句<br>}<br>上面的写法等价 for ; ;是一个无限循环，通常需要配合break语句使用。</li>
</ol>
<h4 id="遍历的两种方法"><a href="#遍历的两种方法" class="headerlink" title="遍历的两种方法"></a>遍历的两种方法</h4><ol>
<li>for-range</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//for-range方式遍历</span><br><span class="line">func main() &#123;</span><br><span class="line">str := &quot;hello,wrold!北京&quot;</span><br><span class="line">for index, val := range str &#123;</span><br><span class="line">	fmt.Printf(&quot;index=%d val=%c\n&quot;, index, val)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>&#x2F;&#x2F;传统方式遍历字符串，不能含中文</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;hello,wrold!&quot;</span><br><span class="line">for i:= 0; i&lt;len(str); i++ &#123;</span><br><span class="line">fmt.Printf(&quot;i=%dval=%c \n&quot;, i, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：GO语言中没有while 和 do……while</strong></p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要跳出的是那一层语句块。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//这里演示一下指定标签的形式来使用break</span><br><span class="line">lable2:</span><br><span class="line">for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">	// lable1://设置一个标签</span><br><span class="line">	for j := 0; j &lt; 10; j++ &#123;</span><br><span class="line">		if j == 2 &#123;</span><br><span class="line">		// break默认会跳出最近的for循环</span><br><span class="line">		//breaklable1</span><br><span class="line">		break 1able2 </span><br><span class="line">		&#125;</span><br><span class="line">	fmt.Print1n( &quot;j=&quot;,j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>具体使用方法同上。</p>
<h3 id="goto（一般不推荐使用）"><a href="#goto（一般不推荐使用）" class="headerlink" title="goto（一般不推荐使用）"></a>goto（一般不推荐使用）</h3><h2 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>基本用法：</p>
<p>func 函数名 （形参列表）（返回值列表） {</p>
<p>​	执行语句……</p>
<p>​	return 返回值列表</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func cal(n1 int, n2 int) int int &#123;</span><br><span class="line">	...</span><br><span class="line">	return n1 , n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li><p>在Go中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import(</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">//在Go中,函数也是一种数据类型，</span><br><span class="line">//可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用</span><br><span class="line">func getsum(n1 int,n2 int) int &#123;</span><br><span class="line">	return n1 +n2</span><br><span class="line">&#125;</span><br><span class="line">//函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用</span><br><span class="line">func myFun(funvar func(int, int) int，num1 int，num2 int )&#123;</span><br><span class="line">	return funvar(num1,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a := getsum</span><br><span class="line">	fmt.Printf(&quot;a的类型%T,getsum类型是%T&quot;,a,getsum)</span><br><span class="line">	res := a(10，40)//等价res := getsum( 10，40)</span><br><span class="line">	</span><br><span class="line">	//看案例</span><br><span class="line">	res2 :=myFun(getsum,5o,60)</span><br><span class="line">	fmt.Print1n( &quot;res2=&quot;, res2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用!</p>
</li>
<li><p>为了简化数据类型定义，Go支持自定义数据类型<br>基本语法:type自定义数据类型名数据类型理解:相当于一个别名案例: type mylnt int&#x2F;这时mylnt就等价int来使用了.<br>案例: type mySum func(int, int) int&#x2F;&#x2F;这时rysum就等价一个函数类型func(int, int) int</p>
</li>
<li><p>支持对函数返回值命名<br>fune cal(n1 int ,n2 int)( sum int , sub int) {<br>sun &#x3D; n1 + n2<br>sub &#x3D; n1 - n2return</p>
<p>Go支持可变参数<br>&#x2F;&#x2F;支持0到多个参数<br> func sum(args… int) sum int {}<br>&#x2F;&#x2F;支持1到多个参数<br>func sum(n1 int, args… int) sum int { }<br>说明:<br>1.	args是slice切片(相当于数组),通过args[index]可以访问到各个值。<br>1.	注意args后面跟了3个“ . ”，不能多不能少</p>
</li>
</ol>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包的<strong>本质实际上就是创建不同的文件夹</strong>，来存放程序文件</p>
<p>打包基本语法： package 包名</p>
<p>引用包： import “<strong>包的路径</strong>”      注意：包的路径是从 $GOPATH的src下开始的，不用带src，编译器会自动从src下开始引入</p>
<p>注意：</p>
<ol>
<li>为了让其他包的文件可以访问到本包的函数，则函数名的<strong>首字母要大写</strong>，首字母小写的只能在该包内使用</li>
<li>可以给包取别名，取后就不能再用原来的名字了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;unsafe&quot;</span><br><span class="line">	myrand &quot;go_code/project_1/myRand&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果你要编译成一个可执行程序文件，就需要将这个包声明为main,即 package main .这个就是一个语法规范，如果你是写一个库，包名可以自定义。</li>
</ol>
<h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>基本介绍：每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用。</p>
<p>注意：</p>
<ol>
<li>如果一个文件同时包含<strong>全局变量定义</strong>, <strong>init函数</strong>和<strong>main</strong><br><strong>函数</strong>,则执行的流程全局变量定义-&gt;init<br>函数-&gt;main函数I</li>
</ol>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>介绍：Go支持匿名函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用。</p>
<ol>
<li><p>匿名函数使用方式1<br>在定义匿名函数时就直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">	fun := func(n1 int, n2 int) int &#123;</span><br><span class="line">		return n1+n2</span><br><span class="line">	&#125;(10,20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>匿名函数使用方式2<br>将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">	fun := func(n1 int, n2 int) int &#123;</span><br><span class="line">		return n1+n2</span><br><span class="line">	&#125;</span><br><span class="line">	//此时fun变成了函数变量，可以通过fun（1，2）调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>全局匿名函数<br>如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	//fun1就是一个全局匿名函数</span><br><span class="line">	Fun1 = func (n1 int, n2 int) int &#123;</span><br><span class="line">		return n1 *n2</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>基本介绍:闭包就是一个函数和与其相关的引用环境组合的一个整体(实体)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//累加罂</span><br><span class="line">func Addupper() func (int) int &#123;</span><br><span class="line">	var n int = 10</span><br><span class="line">	return func (x int) int &#123;</span><br><span class="line">		n = n+ X</span><br><span class="line">		return n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	//使用前面的代码</span><br><span class="line">	f := AddUpper()</span><br><span class="line">	fmt.Println(f(1))// 11</span><br><span class="line">	fmt.Println(f(2))// 13</span><br><span class="line">	fmt.Println(f(3))// 16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//f(1)相当于 AddUpper()（1），因为函数AddUpper()返回的是函数func (x int) int &#123;</span><br><span class="line">		n = n+ X</span><br><span class="line">		return n</span><br><span class="line">	&#125;,所以AddUpper()（1） = func (x int) int &#123;</span><br><span class="line">		n = n+ X</span><br><span class="line">		return n</span><br><span class="line">	&#125;（1），其中1赋给了x，这是一种匿名函数的使用方法。</span><br></pre></td></tr></table></figure>

<p>对上面代码的说明和总结</p>
<ol>
<li>AddUpper是一个函数，返回的数据类型是fun (int) int</li>
<li>闭包指的是上面第三行到第七行</li>
<li>大家可以这样理解:<strong>闭包是类。函数是操作，n是字段。函数和它使用到n构成闭包。</strong></li>
<li>当我们反复的调用f函数时，因为n是初始化一次，因此每调用一次就进行累计。</li>
<li>我们要搞清楚闭包的关键，就是要分析出返回的函数它使用(引用)到哪些变量，因为函数和它引用到的变量共同构成闭包。</li>
</ol>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>在函数中，程序员经常需要创建资源(比如:数据库连接、文件句柄、锁等)，为了<strong>在函数执行完毕后，及时的释放资源</strong>，Go的设计者提供defer (延时机制)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sum(n1 int, n2 int) int &#123;</span><br><span class="line">//当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈(defer栈)</span><br><span class="line">//当函数执行完毕后，再从defer栈,按照先入后出的方式出栈，执行</span><br><span class="line">defer fmt.Print1n( &quot;ok1 n1=&quot;, n1) //defer 3. ok1 n1 = 10</span><br><span class="line">defer fmt.Print1n( &quot;ok2 n2=&quot;, n2) //defer 2. ok2 n2= 20</span><br><span class="line">res := n1 + n2 // res = 30</span><br><span class="line">fmt.Println(&quot;ok3 res=&quot;, res)// 1.ok3 res= 30return res</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	res := sum( 10，20)</span><br><span class="line">	fmt.Print1n( &quot;res=&quot;, res)// 4.res= 30</span><br><span class="line">&#125;</span><br><span class="line">执行顺序：1234</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈(defer栈)</li>
<li>当函数执行完毕后，再从defer栈,按照先入后出的方式出栈，执行</li>
<li>在defer将语句放入到栈时，也会将相关的值拷贝同时入栈。即后续再改变变量的值时，defer保存的变量值不变。</li>
<li>使用场景：在函数里打开文件等资源时，可以立即defer 关闭资源，避免忘记关闭。</li>
</ol>
<h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><p>错误处理基本说明</p>
<ol>
<li>Go语言追求简洁优雅，所以，Go语言不支持传统的try …catch…finally这种处理。</li>
<li>Go中引入的处理方式为:defer,panic, recover</li>
<li>这几个异常的使用场景可以这么简单描述: Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">	//使用defer + recover来捕获和处理异常</span><br><span class="line">	defer func() &#123;	//defer 了一个匿名函数</span><br><span class="line">		err :=recover() // recover()内置函数，可以捕获到异常</span><br><span class="line">		if err != nil &#123;	//说明捕获到错误    nil 相当于null是所有空值的集合</span><br><span class="line">			fmt.Print1n( &quot;err=&quot;, err)</span><br><span class="line">		&#125;()</span><br><span class="line">	num1 := 10num2 := el</span><br><span class="line">	res := num1 / num2</span><br><span class="line">	fmt.Print1n( &quot;res=&quot;, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><p>Go程序中，也支持自定义错误，使用errors.New和 panic内置函数。</p>
<ol>
<li>errors.New(“错误说明”),会返回一个error类型的值，表示一个错误</li>
<li>panic内置函数,接收一个interface{)类型的值（也就是任何值了）作为参数。可以接收error<br>类型的变量，输出错误信息,并退出程序.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//函数去读取以配置文件init.conf的信息</span><br><span class="line">/如果文件名传入不正确,我们就返回一个自定义的错误</span><br><span class="line">func readconf(name string) (err error) &#123;</span><br><span class="line">	if name == &quot;config.ini&quot; &#123;</span><br><span class="line">	//读取...</span><br><span class="line">		return nil</span><br><span class="line">	else &#123;</span><br><span class="line">	//返回一个自定义错误</span><br><span class="line">		return errors. New(&quot;读取文件错误..&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func teste2() &#123;</span><br><span class="line">	err :=readconf( &quot;config2.ini&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">	//如果读取文件发送错误,就输出这个错误，并终止程序</span><br><span class="line">	panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print1n( &quot;testo2()继续执行....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第七章-数组"><a href="#第七章-数组" class="headerlink" title="第七章 数组"></a>第七章 数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.定义一个数组</span><br><span class="line">var hens [6]float64;</span><br><span class="line">//2.给数组的每个元素赋值，元素的下标是从e开始的o-5</span><br><span class="line">hens[0] = 3.0//hens数组的第一个元素 hens[0]</span><br><span class="line">hens[1] = 5.e //hens数组的第2个元素hens[1]</span><br><span class="line">hens[2] = 1.0</span><br><span class="line">hens[3] =3.4</span><br><span class="line">hens[4] = 2.0</span><br><span class="line">hens[5] = 50.0</span><br><span class="line">//数组的地址可以通过数组名来获取&amp;hens</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>四种初始化数组的方式：</p>
<ol>
<li>var numArro1 [3]int &#x3D; [3]int{1，2，3)</li>
<li>var numArre2 &#x3D; [3]int{(5，6，7}</li>
<li>var numArrO3 &#x3D; […]int{8，9，10}    &#x2F;&#x2F;这里的[…]是规定的写法</li>
<li>var numArre4 &#x3D; […]int{1:800，o: 900,2:999}</li>
<li>strArre5 :&#x3D;[…]string{1:”tom”, o: “jack”,2 : “mary”]}</li>
</ol>
<h3 id="for-range遍历"><a href="#for-range遍历" class="headerlink" title="for-range遍历"></a>for-range遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">	//演示for-range遍历数组</span><br><span class="line">	heroes := [...]string&#123;&quot;宋江&quot;，&quot;吴用”,“卢俊义&quot;&#125;//使用常规的方式遍历，</span><br><span class="line">	for index, value := range heroes &#123;</span><br><span class="line">		fmt.Printf(&quot;i=%v v=%v\n&quot;, index , value)</span><br><span class="line">		fmt.Printf(heroes[%d]=%v\n&quot;, index, heroes[index])</span><br><span class="line">	&#125;</span><br><span class="line">	for _, v := range heroes &#123;</span><br><span class="line">		fmt.Printf(&quot;元素的值=%v\n&quot;, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h3><h4 id="切片的基本介绍"><a href="#切片的基本介绍" class="headerlink" title="切片的基本介绍"></a>切片的基本介绍</h4><ol>
<li>切片的英文是slice</li>
<li>切片是数组的一个引用，因此切片是<strong>引用类型</strong>，在进行传递时，遵守引用传递的机制。</li>
<li>切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。</li>
<li>切片的长度是可以变化的，因此切片是一个可以<strong>动态变化数组</strong>。</li>
<li>切片定义的基本语法:<br>var变量名[]类型<br>比如: var a []int   &#x2F;&#x2F;中括号里不需要长度</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//演示切片的基本使用</span><br><span class="line">	var intArr [5]int = [...]int[1，22，33，66，99&#125;</span><br><span class="line">	//声明/定义一个切片</span><br><span class="line">	//slice := intArr[1:3]</span><br><span class="line">	//1. slice就是切片名</span><br><span class="line">	//2. intArr[1:3]表示slice引用到intArr这个数组</span><br><span class="line">	//3．引用intArr数组的起始下标为1,最后的下标为3(但是不包含3)</span><br><span class="line">	slice := intArr[1:3]</span><br><span class="line">	fmt.Printin( &quot;intArr=&quot;, intArr)</span><br><span class="line">	fmt.Println(&quot;slice的元素是=&quot;, slice)l/22，33</span><br><span class="line">	fmt.Println(&quot;slice的元素个数=&quot;,len(slice)) 1/I</span><br><span class="line">	fmt.Println(&quot;slice的容量=&quot;, cap(slice))//切片的容量是可以动态变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>slice从底层来说，其实就是一个数据结构(struct结构体)</p>
<p>type slice struct {<br>ptr	*[2]int			&#x2F;&#x2F;存放引用的第一个的地址<br>len 	int				&#x2F;&#x2F;长度</p>
<p>cap 	int				&#x2F;&#x2F;容量</p>
<p>}</p>
</li>
<li><p>slice的三种使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法</span><br><span class="line">var intArr [5]int = [...]int[1，22，33，66，99&#125;</span><br><span class="line">//声明并定义一个切片</span><br><span class="line">slice := intArr[1:3]</span><br><span class="line"></span><br><span class="line">//第二种方法</span><br><span class="line">var slice []float64 = make([]float64, 5, 10)</span><br><span class="line">//make的第一个参数表示类型，第二个参数表示长度，第三个表示容量且容量必须大于长度</span><br><span class="line"></span><br><span class="line">//第3种方式:定义一个切片，直接就指定具体数组，使用原理类似make的方式</span><br><span class="line">var strslice []string = []string &#123;&quot;tom&quot;, &quot;jack&quot;, &quot;mary&quot;&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>方式1和方式2的区别：方式1是直接引用数组，这个数组是事先存在的，程序员是可见的。方式2是通过make来创建切片，make也会创建一个数组，是由切片在底层进行维护。程序员是看不见的。</p>
</li>
</ol>
<h4 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h4><p>与数组基本相同</p>
<h4 id="切片的注意事项："><a href="#切片的注意事项：" class="headerlink" title="切片的注意事项："></a>切片的注意事项：</h4><ol>
<li>var slice &#x3D; arr[0:end]可以简写var slice &#x3D; arr[:end]</li>
<li>var slice &#x3D; arr[start:len(arr)]可以简写:var slice &#x3D; arr[start:]</li>
<li>var slice &#x3D; arr[O:len(arr)]可以简写: var slice &#x3D; arr[:]</li>
<li>用append内置函数，可以对切片进行动态追加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用append内置函数，可以对切片进行动态追加</span><br><span class="line">var slice3 [ ]int = []int&#123;100，200,300&#125;//通过append直接给slice3追加具体的元素</span><br><span class="line">slice3 = append(slice3,400,500,600)</span><br><span class="line">fmt.Println(&quot;slice3&quot;, slice3)/ /100，200,300,400,500,600</span><br><span class="line">//通过append将切片slice3追加给slice3</span><br><span class="line">slice3 = append(slice3,slice3...)// 100，200， 300,400，500,600, 100，200，300,400,500,600</span><br><span class="line">fmt.Print1n( &quot;slice3&quot;, slice3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	切片append操作的底层原理分析:</p>
<ul>
<li>切片append操作的本质就是对数组扩容</li>
<li>go底层会创建一下新的数组newArr(安装扩容后大小</li>
<li>将slice原来包含的元素拷贝到新的数组newArr</li>
<li>slice重新引用到newlrr</li>
<li>注意newArr是在底层来维护的，程序员不可见.6)案例演示说明</li>
</ul>
<ol start="5">
<li>切片的拷贝操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//切片的拷贝操作</span><br><span class="line">//切片使用copy内置函数完成拷贝，举例说明</span><br><span class="line">var slice4 []int =[ ]int&#123;1，2，3，4，5&#125;</span><br><span class="line">var slice5 = make([]int，10)</span><br><span class="line">copy(slice5,slice4)			//将4复制给5</span><br><span class="line">fmt.Print1n(&quot;slice4=&quot;, slice4)// 1， 2，3，4，5</span><br><span class="line">fmt.Print1n( &quot;slice5=&quot;, slice5)// 1，2，3，4,5,0，0，0，0，0</span><br></pre></td></tr></table></figure>

<h4 id="string和slice"><a href="#string和slice" class="headerlink" title="string和slice"></a>string和slice</h4><ol>
<li><p>string底层是一个byte数组，因此string也可以进行切片处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//string底层是一个byte数组，因此string也可以进行切片处理</span><br><span class="line">str := &quot;hello@atguigu&quot;</span><br><span class="line">//使用切片获取到atguigu</span><br><span class="line">slice := str[6:]</span><br><span class="line">fmt.Print1n(&quot;slice=&quot;, slice)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>string是不可变的，也就说不能通过str[0]&#x3D; ‘z’方式来修改字符串【演示】<br>如果需要修改字符串，可以先将string -&gt; []byte&#x2F;或者[]rune -&gt;修改-&gt;重写转成string.【演示＋说明】</p>
</li>
</ol>
<h2 id="第八章-map"><a href="#第八章-map" class="headerlink" title="第八章 map"></a>第八章 map</h2><p>map是key-value数据结构，又称为字段或者关联数组。类似其它编程语言的集合，在编程中是经常使用到</p>
<h3 id="map的声明"><a href="#map的声明" class="headerlink" title="map的声明"></a>map的声明</h3><p>基本语法<br>var	map变量名	map[keytype]valuetype<br>key可以是什么类型？<br>golang中的map的 key可以是很多种类型，比如bool,数字，string,指针，channel ,还可以是只包含前面几个类型的接口，结构体,数组<br>通常为int . string<br>注意: slice，map还有function不可以，因为这几个没法用&#x3D;&#x3D;来判断</p>
<p><strong>在使用map前，雷要先make , make的作用就是给map分配数据空间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map声明的举例:</span><br><span class="line">var a map[string]string</span><br><span class="line">var a map[string]int</span><br><span class="line">var a map[int]string</span><br><span class="line">var a map[string]map[string]string</span><br><span class="line">注意:声明是不会分配内存的，初始化需要make ，分配内存后才能赋值和使用。</span><br><span class="line">//在使用map前，雷要先make , make的作用就是给map分配数据空间a = make(map[ string]string,10)</span><br><span class="line">a[ &quot;no1&quot;]=“宋江”//ok?</span><br><span class="line">a[ &quot;no2&quot;]=“吴用”//ok ?</span><br><span class="line">a[ &quot;no1&quot;]=“武松”//ok?</span><br><span class="line">a[ &quot;no3&quot;&quot;]=“吴用”//ok?</span><br></pre></td></tr></table></figure>

<h3 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h3><p>三种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一种</span><br><span class="line">var a map[string]string</span><br><span class="line">//在使用map前，需要先make , make的作用就是给map分配数据空间a = make(map[string]string，10)</span><br><span class="line">a[ &quot;no1&quot;] =&quot;宋江”//ok?</span><br><span class="line">a[&quot;no2&quot;]=&quot;吴用”//ok?</span><br><span class="line">a[ &quot;no1&quot;] =&quot;武松”//ok?</span><br><span class="line">a[ &quot;no3&quot;]=&quot;吴用”//ok?</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二种方式</span><br><span class="line">cities := make(map[string]string)cities [&quot;no1&quot;]=&quot;北京&quot;</span><br><span class="line">cities[ &quot;no2&quot;]=&quot;天津&quot;cities[ &quot;no3&quot;]=“上海”fmt.Print1n(cities)</span><br><span class="line"></span><br><span class="line">//第三种方式</span><br><span class="line">heroes := map[string]string&#123;</span><br><span class="line">&quot;hero1&quot; :“宋江”,</span><br><span class="line">&quot;hero2&quot;:“卢俊义&quot;,</span><br><span class="line">&quot;hero3&quot; : &quot;叶&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print1n( &quot;heroes=&quot;, heroes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map的增删改查操作"><a href="#map的增删改查操作" class="headerlink" title="map的增删改查操作"></a>map的增删改查操作</h3><ol>
<li><p>map增加和更新: map[“key”] &#x3D; value ll如果key还没有，就是增加，如果key存在就是修改。</p>
</li>
<li><p>map删除:</p>
<p>说明:delete(map，”key”),delete是一个内置函数，如果key存在，就删除该key-value,如果key不存在，不操作，但是也不会报错</p>
<p>细节说明</p>
<ol>
<li>如果我们要删除map的所有key ,没有一个专门的方法一次删除，可以遍历一下key,逐个删除</li>
<li>或者map &#x3D; make(…)，make一个新的，让原来的成为垃圾，被gc回收</li>
</ol>
</li>
<li><p>map查找</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//演示mpp的查找</span><br><span class="line">val, ok := cities[ &quot;no1&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">	fmt.Printf(&quot;有no1 key值为%v\n&quot;, val)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">	fmt.Printf(没有no1 key\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//使用for-range遍历map//第二种方式</span><br><span class="line">	cities := make(map[string]string)</span><br><span class="line">	cities[ &quot;no1&quot;] =“北京&quot;</span><br><span class="line">	cities[&quot;no2&quot;]=“天津&quot;</span><br><span class="line">	cities [&quot;no3&quot;] =“上海”</span><br><span class="line">	for k, v := range cities &#123;</span><br><span class="line">		fmt.Printf(&quot;k=%v v=%v\n&quot;, k,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map的长度"><a href="#map的长度" class="headerlink" title="map的长度"></a>map的长度</h3><p>案例演示:fmt.Println(<em><strong>len(stus)</strong></em>)</p>
<h3 id="map切片"><a href="#map切片" class="headerlink" title="map切片"></a>map切片</h3><p>基本介绍<br>切片的数据类型如果是map，则我们称为slice of map,map切片，这样使用则map个数就可以动态变化了。<strong>其实切片还是相当于动态数组，map切片就相当于用于存放map的动态数组</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1．声明一个map切片</span><br><span class="line">var monsters []map[string]string</span><br><span class="line">monsters = make([]map[string]string， 2)//准备放入两个妖怪</span><br><span class="line">//2．增加第一个妖怪的信息</span><br><span class="line">if monsters[0] == nil &#123;</span><br><span class="line">	monsters[0] = make(map[ string]string, 2)</span><br><span class="line">	monsters[o][&quot;name&quot;]=&quot;牛魔王&quot;</span><br><span class="line">	monsters[0][&quot;age&quot;] = &quot;500&quot;</span><br><span class="line">&#125;</span><br><span class="line">if monsters[1] == nil &#123;</span><br><span class="line">	monsters[1] = make(map[string]string,2)</span><br><span class="line">	monsters[1][&quot;name&quot;] =“玉兔精”</span><br><span class="line">	monsters[1][ &quot;age&quot;] = &quot;400&quot;</span><br><span class="line">&#125;</span><br><span class="line">//这里我们需要使用到切片的append函数，可以动态的增加monster//1．先定义个monster信息</span><br><span class="line">newMonster := map[string]string&#123;</span><br><span class="line">&quot;name” :&quot;新的妖怪~火云邪神&quot;,&quot;age&quot; : &quot;2oe&quot;,</span><br><span class="line">&#125;</span><br><span class="line">monsters =..append(monsters, newMonster)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h3><p>基本介绍</p>
<ol>
<li>golang中没有一个专门的方法针对map的key进行排序</li>
<li>golang中的map默认是无序的，注意也不是按照添加的顺序存放的，你每次遍历，得到的输出可能不一样.</li>
<li>golang中map的排序，是先将key进行排序，然后根据key值遍历输出即可</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//如果按照map的key的顺序进行排序输出</span><br><span class="line">//1．先将map的key放入到切片中</span><br><span class="line">//2．对切片排序</span><br><span class="line">//3．遍历切片,然后按照key来输出map的值</span><br><span class="line">var keys []int</span><br><span class="line">for k,_ := range map1 &#123;</span><br><span class="line">	keys = append(keys,k)</span><br><span class="line">&#125;</span><br><span class="line">//排序</span><br><span class="line">sort.Ints(keys)</span><br><span class="line">fmt.Print1n(keys)</span><br><span class="line">for _, k := range keys&#123;</span><br><span class="line">	fmt.Printf( &quot;map1[%v】=%v ln&quot;, k, mapl[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="map使用细节"><a href="#map使用细节" class="headerlink" title="map使用细节"></a>map使用细节</h3><ol>
<li>map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map</li>
<li>map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic，也就是说map能动态的增长键值对(key-value)</li>
<li>map的value也经常使用struct类型，更适合管理复杂的数据(比前面value是一个map更好)，比如value为Student结构体【案例演示，因为还没有学结构体，体验一下即可】</li>
<li>map的key和value类型必须一致。</li>
</ol>
<h2 id="第九章-面向”对象“编程"><a href="#第九章-面向”对象“编程" class="headerlink" title="第九章  面向”对象“编程"></a>第九章  面向”对象“编程</h2><h3 id="面向对象编程说明"><a href="#面向对象编程说明" class="headerlink" title="面向对象编程说明"></a>面向对象编程说明</h3><ol>
<li>golang与传统的面向对象编程有区别，它不纯粹，golang支持面向对象编程特性</li>
<li>golang没有类，golang基于struct来实现面向对象OOP特性的</li>
<li>golang面向对象编程简洁，去掉了传统oop语言继承，方法重载，构造函数，析构函数，隐藏的this指针等</li>
<li>仍具有继承，封装，多态的特性，实现方式有些不同：golang没有extend，继承是通过匿名字段实现</li>
<li>通过接口关联，耦合性低，面向接口编程</li>
</ol>
<h3 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">	color string</span><br><span class="line">	Hobby string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）声明方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）直接声明</span><br><span class="line">	var person Person</span><br><span class="line">（2）&#123;&#125;</span><br><span class="line">	var person Person =Person&#123;&quot;mary&quot;,20&#125;</span><br><span class="line">（3）&amp;</span><br><span class="line">	var person *Person =new（Person）</span><br><span class="line">	(*p3).name = &quot;abc&quot;</span><br><span class="line">	p3.name = &quot;cba&quot;</span><br><span class="line">（4）&#123;&#125;</span><br><span class="line">	var person *Person=&amp;Person&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;&#x2F;3和4方式返回的是结构体指针</strong></p>
<p>eg：var p3 *Person&#x3D;new(Person)</p>
<p>​      (*p3).Name &#x3D;”xx”&#x2F;&#x2F;等价于p3.Name&#x3D;”xx”</p>
<p>​      (*p3).Age&#x3D;30&#x2F;&#x2F;等价于p3.Age&#x3D;30 原因：为了程序员方便，底层给p3自动加上取值运算（ *p3）</p>
<h4 id="创建结构体变量时指定字段值"><a href="#创建结构体变量时指定字段值" class="headerlink" title="创建结构体变量时指定字段值"></a>创建结构体变量时指定字段值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（1）var stu1 Student =student&#123;&quot;Tom&quot;,10&#125;</span><br><span class="line">stu2 :=Student&#123;&quot;tom&quot;,10&#125;</span><br><span class="line">或者var stu2 Student =Student&#123;</span><br><span class="line">        Name:&quot;Tom&quot;,</span><br><span class="line">      Age:10,</span><br><span class="line">&#125;</span><br><span class="line"> stu2 Student :=Student&#123;</span><br><span class="line">        Name:&quot;Tom&quot;,</span><br><span class="line">       Age:10,</span><br><span class="line">&#125;</span><br><span class="line">(2)返回结构体的指针类型</span><br><span class="line">var stu1 *Student =&amp;student&#123;&quot;Tom&quot;,10&#125;</span><br><span class="line">var stu2 *Student =&amp;Student&#123;</span><br><span class="line">        Name:&quot;Tom&quot;,</span><br><span class="line">      Age:10,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字段-属性"><a href="#字段-属性" class="headerlink" title="字段&#x2F;属性"></a>字段&#x2F;属性</h3><p>注意事项和细节说明</p>
<ol>
<li>字段声明语法同变量,示例:字段名字段类型</li>
<li>字段的类型可以为:基本类型、数组或引用类型</li>
<li>在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)，规则同前面讲的一样:布尔类型是false ，数值是0，字符串是””。数组类型的默认值和它的元素类型相关，比如score [3]int则为[0,0,0]</li>
<li><strong>指针,slice，和map的零值都是nil，即还没有分配空间。</strong></li>
<li>不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个。</li>
<li><strong>结构体是值拷贝</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 peson = p0</span><br><span class="line">p1和p0在内存是两个地方，只是值复制而已</span><br></pre></td></tr></table></figure>

<h3 id="结构体的使用注意事项和细节"><a href="#结构体的使用注意事项和细节" class="headerlink" title="结构体的使用注意事项和细节"></a>结构体的使用注意事项和细节</h3><ol>
<li><p>结构体的所有字段在内存中是连续分布的</p>
</li>
<li><p>结构体和其他类型进行转换时需要有完全相同的字段（名字，个数，类型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type A struct &#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line">type B struct &#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a Avar b B</span><br><span class="line">	a = A(b)// ?</span><br><span class="line">	fmt.Println(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>结构体进行type重新定义（取别名）golang认为是新的数据类型，但是相互间可以强转</p>
</li>
<li><p>struct每个字段可以写上一个tag，tag可以通过反射机制获取，常见的使用场景就是序列化和反序列化（将struct变量进行json处理）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import “encoding/json”</span><br><span class="line"></span><br><span class="line">type Monster struct&#123;</span><br><span class="line"></span><br><span class="line">​    Name string ` json:&quot;name&quot; `</span><br><span class="line"></span><br><span class="line">​    Age int `json:“age”`</span><br><span class="line"></span><br><span class="line">   Skill string `json:skill&quot;`</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line"></span><br><span class="line">​    monster :=Monster&#123;&quot;xx&quot;,500,&quot;xxx&quot;&#125;</span><br><span class="line"></span><br><span class="line">​    jsonStr,err:=json.Marshal(monster)//json.Marshal函数用到反射，将monster变量序列化为json格式</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;jsonStr&quot;,string(jsonStr))//把Name改为name...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>golang中方法是作用在指定的数据类型上的，因此自定义类型都可以有方法，而不仅仅是struct（前提是自定义类型，int这些是不能直接用的，要用也要用type interger int重命名一下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type A struct&#123;</span><br><span class="line">    Num int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a A) test()&#123;</span><br><span class="line">//表示A结构体有一个方法，名为test,这里面的a表示哪个A变量调用，a就是它的副本，和函数传参相似</span><br><span class="line">       fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line">var t A</span><br><span class="line">t.test()//对的</span><br><span class="line">test()//错的</span><br></pre></td></tr></table></figure>

<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>方法的声明(定义)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (recevier type) methodName（参数列表)(返回值列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">	return返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>参数列表:表示方法输入</li>
</ol>
<ol start="2">
<li>recevier type :表示这个方法和type这个类型进行绑定，或者说该方法作用于type类型</li>
<li>receiver type : type可以是结构体，也可以其它的自定义类型</li>
<li>receiver:就是type类型的一个变量(实例，比如:Person结构体的一个变量(实例)</li>
<li>参数列表:表示方法输入</li>
<li>返回值列表:表示返回的值,可以多个7)方法主体:表示为了实现某一功能代码块)return语句不是必须的。</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>方法的调用和传参机制和函数基本一致，不一样的地方是方法调用时会将调用方法的变量当做实参传递给方法（变量为值类型则值拷贝，若为引用类型则地址拷贝）</li>
<li>结构体类型为值类型，值拷贝传递方式，若希望在方法中修改结构体变量的值，可以通过结构体指针方式处理</li>
<li>golang中的方法作用在指定的数据类型，不一定需要struct，int，float32这些都行</li>
<li>方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，首字母大写，可以在本包和其他包访问</li>
<li>如果一个类型实现了String（）方法，那么fmt.Println默认会调用这个类型的String（）进行输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Student struct&#123;</span><br><span class="line"> Name string</span><br><span class="line"> Age int</span><br><span class="line">&#125;</span><br><span class="line">func(stu *Student) String() string&#123;</span><br><span class="line">        str :=fmt.Sprintf(&quot;Name=[%v] Age=[%v],stu.Name,stu.Age&quot;)</span><br><span class="line">        return str</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">     stu :=Student&#123;</span><br><span class="line">          Name : &quot;tom&quot;,</span><br><span class="line">          Age : 20,</span><br><span class="line">&#125;</span><br><span class="line">          fmt.Println(&amp;stu)//如果实现了 *student类型的String方法，则会自动调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法与函数的区别"><a href="#方法与函数的区别" class="headerlink" title="方法与函数的区别"></a>方法与函数的区别</h4><p>对于函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然，对于方法，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样可以（这里针对的绑定的类型）</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>用于初始化结构体或者解决结构体没有构造函数的问题</p>
<h3 id="三大特性：封装，继承，接口"><a href="#三大特性：封装，继承，接口" class="headerlink" title="三大特性：封装，继承，接口"></a>三大特性：封装，继承，接口</h3><h4 id="封装（有点类似java）："><a href="#封装（有点类似java）：" class="headerlink" title="封装（有点类似java）："></a>封装（有点类似java）：</h4><p>1）将结构体，字段的首字母小写（不能导出，其他包不能使用，<strong>类似private</strong>）</p>
<p>2）给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数</p>
<p>3）提供一个首字母大写的Set方法（类似于public），对属性判断并赋值</p>
<p>4）提供一个首字母大写的Get方法，用于获取属性的值</p>
<h4 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h4><ol>
<li>嵌套匿名结构体的基本语法</li>
</ol>
<p>eg：type Goods struct{</p>
<p>​     Name string</p>
<p>​     Price int</p>
<p>}</p>
<p>type Book struct{</p>
<p>​      Goods</p>
<p>​    Writer string</p>
<p>}</p>
<ol start="2">
<li><p>匿名结构体字段访问可以简化比如b继承A</p>
<p>b.A.name&#x3D;”tom”可以简化为b.name&#x3D;”tom”</p>
</li>
<li><p>当结构体和匿名结构体有相同字段或者方法时，编译器采用就近访问原则，如希望访问匿名结构体的字段和方法。可以通过匿名结构体名来区分</p>
</li>
<li><p>结构体嵌入两个匿名结构体，如两个匿名结构体中有相同的字段和方法（同时结构体本身没有同名的字段和方法），在访问时，就<strong>必须明确指定匿名结构体名字</strong>，不然报错</p>
</li>
<li><p>如果一个struct嵌套了一个有名结构体，这种就是<strong>组合</strong>，如果是组合关系，在访问组合的结构体的字段或方法时，必须带上结构体的名字</p>
</li>
</ol>
<p>eg：type A struct{</p>
<p>​     Name string</p>
<p>​    Age int</p>
<p>}</p>
<p>type D struct{</p>
<p>   a A</p>
<p>}</p>
<p>比如 var d D</p>
<p>d.Name &#x3D; “jack”&#x2F;&#x2F;报错，它是组合关系，不会往A上找</p>
<p>d.a.Name &#x3D; “jack”&#x2F;&#x2F;ok</p>
<ol start="6">
<li>嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct&#123;</span><br><span class="line">      Name string</span><br><span class="line">      Price float64</span><br><span class="line">&#125;</span><br><span class="line">type Brand struct&#123;</span><br><span class="line">     Name string</span><br><span class="line">     Address string</span><br><span class="line">&#125;</span><br><span class="line">type TV struct&#123;</span><br><span class="line">     Goods</span><br><span class="line">     Brand</span><br><span class="line">&#125;</span><br><span class="line">//type TV2 struct&#123;</span><br><span class="line">    *Goods</span><br><span class="line">    *Brand</span><br><span class="line">&#125;</span><br><span class="line">tv:=TV&#123; Goods&#123;&quot;电视机001&quot;,5000.99&#125;, Brand&#123;&quot;海尔&quot;,&quot;山东&quot;&#125;,&#125;</span><br><span class="line">//tv2:=TV2&#123; &amp;Goods&#123;&quot;电视机001&quot;,5000.99&#125;, &amp;Brand&#123;&quot;海尔&quot;,&quot;山东&quot;&#125;,&#125;用指针传更快</span><br><span class="line">//fmt.Println(*tv3.Goods,*tv3.Brand)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>基本类型作字段</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Monster struct&#123;</span><br><span class="line">      Name string</span><br><span class="line">       Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type E struct &#123;</span><br><span class="line">     Monster</span><br><span class="line">     int//基本类型直接作为字段</span><br><span class="line">&#125;</span><br><span class="line">var e E</span><br><span class="line">e.Name=&quot;xx&quot;</span><br><span class="line">e.int=20</span><br></pre></td></tr></table></figure>

<h4 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h4><p>interface类型可以定义一组方法，不需要实现，并且interface不能包含任何变量，只有实现接口中的所有方法，才算实现了接口</p>
<p>基本语法：</p>
<p>type 接口名 interface{</p>
<p>​    method1（参数列表）返回值列表</p>
<p>​    method2（参数列表）返回值列表</p>
<p>   ……..</p>
<p>  }</p>
<p>1） 接口中所以方法都没有方法体</p>
<p>2）golang中接口不需要显式实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。</p>
<p>3）接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量</p>
<p>4）只要是自定义数据类型，都可以实现接口，不仅仅是结构体类型</p>
<p>5）一个自定义可以实现多个接口</p>
<p>6）一个接口A也可以继承多个别的接口B，C。这时要实现A接口，也必须将B，C接口的方法全部实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type A interface&#123;</span><br><span class="line">       test01()</span><br><span class="line">&#125;</span><br><span class="line">type B interface&#123;</span><br><span class="line">       test02() </span><br><span class="line">&#125;</span><br><span class="line">type C interface&#123;</span><br><span class="line">        B</span><br><span class="line">        A</span><br><span class="line">       test03() </span><br><span class="line">&#125;</span><br><span class="line">只有实现了3个test才能实现C接口</span><br></pre></td></tr></table></figure>

<p>7）interface类型默认为指针（引用类型），如果没有初始化，则会输出nil</p>
<p>8）空接口interface{}没有任何方法，所有类型都实现了空接口</p>
<p>eg：type T interface{<br>}</p>
<p>var t T&#x3D;stu&#x2F;&#x2F;ok</p>
<p>var t2 interface{} &#x3D;stu&#x2F;&#x2F;ok </p>
<p>9）接口体现的多态：</p>
<p>（1）多态参数：Usb接口案例中，Usb usb既可以接受手机变量，又可以接收相机变量，体现了多态</p>
<p>（2）多态数组：给Usb数组中，存放Phone结构体，Camera结构体变量</p>
<p>eg： </p>
<p>var usbArr [3]Usb</p>
<p>usbArr[0]&#x3D;Phone{“vivo”}</p>
<p>usbArr[1]&#x3D;Phone{“小米”}</p>
<p>usbArr[2]&#x3D;Camera{“尼康”}</p>
<h4 id="类型断言："><a href="#类型断言：" class="headerlink" title="类型断言："></a>类型断言：</h4><p><strong>将接口变量转成具体类型的变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> eg：type Point struct&#123;</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">var point Point =Point&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line">a=point</span><br><span class="line"></span><br><span class="line">var b Point</span><br><span class="line"></span><br><span class="line">//b=a error</span><br><span class="line"></span><br><span class="line">//b=a.(Point) ok 类型断言：将接口变量转成具体类型的变量</span><br><span class="line"></span><br><span class="line">b,ok:=a.(Point)</span><br><span class="line"></span><br><span class="line">if ok== true&#123;</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;convert success&quot;)</span><br><span class="line"></span><br><span class="line">  fmt.Printf(&quot;b的类型数%T 值是=%v&quot;，b，b)</span><br><span class="line"></span><br><span class="line">&#125; else&#123;</span><br><span class="line"></span><br><span class="line"> fmt.Println(&quot;convert fail&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十章-文件操作：（os包）"><a href="#第十章-文件操作：（os包）" class="headerlink" title="第十章 文件操作：（os包）"></a>第十章 文件操作：（os包）</h2><ol>
<li><p>打开：file,err:&#x3D;os.Open(“d:&#x2F;test.txt”)</p>
</li>
<li><p>关闭：err&#x3D;file.Close()&#x2F;&#x2F;常常直接打开后用defer file.Close()</p>
</li>
<li><p>读文件操作</p>
</li>
</ol>
<p>(1)读文件内容并显示在终端（带缓冲的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file,err:=os.Open(&quot;d:/test.txt&quot;)</span><br><span class="line">defer file.Close()</span><br><span class="line">reader:=bufio.NewReader(file)//默认缓冲区为4096</span><br><span class="line">for&#123;</span><br><span class="line">str,err:= reader.ReadString(&#x27;\n&#x27;)//读到一个换行就结束</span><br><span class="line">if err==io.EOF&#123;//io.EOF表示文件末尾</span><br><span class="line">    break</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)读取文件内容并显示在终端（ioutil异常将整个文件读入内存），适用于内存不大的情况（io&#x2F;ioutil包）</p>
<p>但这种方法已经过时了，ioutil.ReadFile(file)该改为os.ReadFile(file)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file := &quot;e:/test.txt&quot;</span><br><span class="line">content, err := os.ReadFile(file)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">    fmt.Printf(&quot;%s&quot;, content)</span><br><span class="line">&#125;//注意返回的是切片</span><br></pre></td></tr></table></figure>

<p>4）读文件</p>
<p>os.OpenFile(name string,flag int,perm FileMode)(file *File,err error)&#x2F;&#x2F;第二个参数：文件打开模式（可以组合详见文档），第三个参数：权限控制（linux下有用，win下没用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defer file.Close()</span><br><span class="line">writer :=bufio.NewWriter(file)</span><br><span class="line">writer.WriterString(str)</span><br><span class="line">writer.Flush()//将写入缓存的内容真正写入文件中</span><br></pre></td></tr></table></figure>

<p>5)判断文件或文件夹是否存在</p>
<p>os.Stat()函数</p>
<p>如果返回错误为nil，则文件或文件夹存在，若错误能用os.IsNotExist()判断为true,则说明文件或文件夹不存在，若干错误为其他类型，则不确定是否存在</p>
<p>6）文件拷贝</p>
<p>func Copy（dst Writer，src Reader）（written int64，err error）</p>
<p>7）命令行参数</p>
<p>os.Args是一个string的切片，用来存储所有的命令行参数</p>
<p>8）flag包解析命令行参数</p>
<p>感觉没啥用</p>
<h4 id="json-key-value"><a href="#json-key-value" class="headerlink" title="json(key-value):"></a>json(key-value):</h4><p>先将数据序列化为json字符串进行传输，接收方收到后反序列化恢复为原来的数据类型</p>
<p><a target="_blank" rel="noopener" href="https://www.json.cn/%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E9%AA%8C%E8%AF%81json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE">https://www.json.cn/网站可以验证json格式的数据是否正确</a></p>
<ol>
<li>json的序列化（ 一般对切片，结构体，map进行序列化，对基本类型序列化意义不大）（包来自encoding&#x2F;json)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data,err :=json.Marshal(&amp;monster)//按引用方式传递</span><br><span class="line">if err !=nil&#123;</span><br><span class="line">       fmt.Printf(&quot;err=%v\n&quot;,err) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fmt.Printf(“monster序列化后&#x3D;%v\n”,string(data))</p>
<ol start="2">
<li>json的反序列化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str :=&quot;&#123;.....&#125;&quot;//获得的json字符串</span><br><span class="line">var monster Monster</span><br><span class="line">err :=json.Unmarshal([]byte(str),&amp;monster)//反序列化map前，不需要make，make被封装到Unmarshal函数中了，序列化时一定要记着make</span><br><span class="line">if err != nil&#123;</span><br><span class="line">fmt.Println(&quot;err&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;反序列化后monster=%v\n&quot;,monster)</span><br></pre></td></tr></table></figure>

<h4 id="go中进行单元测试："><a href="#go中进行单元测试：" class="headerlink" title="go中进行单元测试："></a>go中进行单元测试：</h4><p>cal_test.go:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import(</span><br><span class="line">  &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line">func TestAddUpper(t *testing.T)&#123;</span><br><span class="line"> res :=addUpper（10）</span><br><span class="line"> if res !=55&#123;</span><br><span class="line">       t.Fatalf(&quot;wrong&quot;)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> t.Logf(&quot;right&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cal.go:</p>
<p>func addUpper(i int) int{</p>
<p>…….</p>
<p>}</p>
<p>总结：test框架将xxx__test.go文件引入import</p>
<p>main(){</p>
<p>&#x2F;&#x2F;2.调用TestXxx函数</p>
<p>}</p>
<p>注意事项：</p>
<p>1）测试用例文件名必须以_test.go结尾</p>
<p>2）测试用例函数必须以Test开头，而且后面那个字母不能是a-z</p>
<p>3）形参类型必须是*testing.T</p>
<p>4）运行指令：</p>
<p>（1）go test(错误才输出日志)</p>
<p>   (2) go test -v（正确错误都输出日志）</p>
<p>5）常用t.Fatal和t.Logf</p>
<p>6）测试单个文件，一定要带上被测试的源文件</p>
<p>go test -v cal_test.go cal.go</p>
<p>7）测试单个方法</p>
<p>go test -v -test.run TestAddUpper</p>
<h2 id="第十一章-线程"><a href="#第十一章-线程" class="headerlink" title="第十一章 线程"></a>第十一章 线程</h2><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine:"></a>goroutine:</h4><ol>
<li>go协程与go主线程</li>
</ol>
<p>主线程可以理解为线程或者进程，一个go线程上们可以起多个协程，协程换句话说是轻量级的线程</p>
<p>协程特点：有独立的栈空间，共享程序堆空间，调度由用户控制，协程是轻量级的线程</p>
<ol start="2">
<li>协程写法的简单暴力</li>
</ol>
<p>func test（）{</p>
<p>​      …..</p>
<p>}</p>
<p>func main(){</p>
<p>  go test()&#x2F;&#x2F;开启协程了</p>
<p>…….</p>
<p>}</p>
<ol start="3">
<li><p>主线程是一个物理线程，直接作用在cpu上。是重量级的，非常耗费cpu资源，协程是轻量级的线程，是逻辑态</p>
</li>
<li><p>MPG模式</p>
</li>
</ol>
<p>M：操作系统的主线程</p>
<p>P：协程执行需要的上下文</p>
<p>G：协程</p>
<ol start="5">
<li>golang中设置允许cpu数量（runtime包）</li>
</ol>
<p>cpuNum :&#x3D; runtime.NumCPU()&#x2F;&#x2F;查看cpu个数</p>
<p>rumtime.GOMAXPROCS(cpuNum-1)&#x2F;&#x2F;设置最多能用多少个cpu</p>
<ol start="6">
<li>加锁解锁（sync包）</li>
</ol>
<p>var lock sync.Mutex</p>
<p>lock.Lock()</p>
<p>xxxxx</p>
<p>lock.Unlock()</p>
<h4 id="channel："><a href="#channel：" class="headerlink" title="channel："></a>channel：</h4><p>1）为什么需要channel：主线程等待所有goroutine全部完成实际很难确定，只能估算，而且利用加锁同步实现通讯不利于多个协程对全局变量的读写操作</p>
<p>2）channel本质为队列，先进先出，channel具有数据类型，对应数据类型进对应管道</p>
<p>3）channel的基本使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 chan 数据类型//channel为引用类型，必须用make进行初始化</span><br><span class="line">var intChan chan int</span><br><span class="line">intChan =make(chan int,3)</span><br><span class="line">intChan &lt;- 10//向管道写入数据</span><br><span class="line">num:=211</span><br><span class="line">intChan &lt;- num</span><br><span class="line">num2 := &lt;- intChan//从管道中取数据</span><br></pre></td></tr></table></figure>

<p>4）channel的关闭</p>
<p><strong>关闭了只能读，不能写</strong></p>
<p>close（intChan）</p>
<p>5）channel的遍历</p>
<p>支持for-range遍历，<strong>在遍历时，channel没有关闭，则会出现deadlock错误</strong>，如果channel已经关闭，则会正常遍历数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close(intChan2)</span><br><span class="line">for v:=range intChan2 &#123;</span><br><span class="line">    fmt.Println(&quot;v=&quot;,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）channel可以声明为只读或者只写</p>
<p><strong>只写： var chan2 chan&lt;- int</strong></p>
<p>chan2 &#x3D;make(chan int,3)</p>
<p>chan2&lt;- 20</p>
<p><strong>只读： var chan3 &lt;-chan int</strong></p>
<p>chan3 &#x3D;make(chan int ,3)</p>
<p>num2 :&#x3D; &lt;- chan3</p>
<p>7)使用select解决从管道取数据的阻塞问题（感觉没啥用）（不好确定什么时候关闭该管道时可以这样做）</p>
<p>select{         </p>
<p>​         case v :&#x3D;&lt;-管道：</p>
<p>​          语句</p>
<p>​        default：</p>
<p>​        语句</p>
<p>}</p>
<p>8）goroutine中使用recover，解决协程中出现panic的问题：（<strong>有点类似Java中的try-catch</strong>），可以不影响整个进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">  defer func()&#123;</span><br><span class="line">      if err :=recover();err !=nil&#123;</span><br><span class="line">      fmt.Println(&quot;test()error&quot;,err)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">var myMap map[int]string</span><br><span class="line">myMap[0] = &quot;golang&quot;//wrong</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">      go test()</span><br><span class="line">      go sayHello()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h4><p>1）在运行时动态获取变量的各种信息，如类型，类别，通过反射，可以修改变量的值，可以调用关联的方法，使用反射，<strong>需要import reflect包</strong></p>
<p>2）反射重要的函数：</p>
<p>（1）reflect.TypeOf(变量名)，获取变量的类型</p>
<p>（2） reflect.ValueOf(变量名），获取变量的值</p>
<p>3）变量，interface{}和reflect.Value是可以相互转换的</p>
<p>4）eg：</p>
<p>func reflectTest01(b interface{}){</p>
<p> rTyp :&#x3D;reflect.TypeOf(b)&#x2F;&#x2F;获取reflect.Type，值为int，stu值为main（包名）.Student</p>
<p>rVal :&#x3D;reflect.ValueOf(b)&#x2F;&#x2F;获取reflect.Value,值为100,，值为结构体里的字段但rVal的类型不是int，是reflect.Value，反射是运行时进行，而不是编译时进行，所以无法通过rVal.name，iV.name访问字段的内容，只有通过类型断言实现</p>
<p>iv：&#x3D;rVal.Interface()&#x2F;&#x2F;rVal转为interface{}</p>
<p>num2:&#x3D;iV.(int)&#x2F;&#x2F;类型断言</p>
<p>stu，ok :&#x3D;iV.(Student)</p>
<p>kind1 :&#x3D; rVal.Kind()&#x2F;&#x2F;以结构体为例，值为struct</p>
<p>}</p>
<p> func main(){</p>
<p>​         n:&#x3D;100</p>
<p>​        reflectTest01(n)</p>
<p>​      reflectTest02（stu）&#x2F;&#x2F;反射结构体</p>
<p>}</p>
<p>5）通过set修改值</p>
<p>func reflect01(b interface{}){</p>
<p> rVal:&#x3D; reflect.ValueOf(b)</p>
<p>rVal.Elem().SetInt(20)&#x2F;&#x2F;Elem返回持有接口或者指针保管的值</p>
<p>}</p>
<p>  func main(){</p>
<p>reflect01(&amp;num)</p>
<p>}</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">→╋ぁ陈ぁ╋←</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/13/go%E8%AF%AD%E8%A8%80/">http://example.com/2023/09/13/go%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">cyc的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/08/%E8%BD%A6%E8%BD%BD%E7%BD%91/" title="车载网"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">车载网</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/12/%E5%85%B6%E4%BB%96/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">→╋ぁ陈ぁ╋←</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">go语言学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">实用代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.	随机数生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-go%E6%96%87%E4%BB%B6%E5%A4%A7%E8%87%B4%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.</span> <span class="toc-text">第一章 go文件大致模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">第二章 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">查看变量占用的字节大小和数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Estring%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">基本数据类型与string类型的互相转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.3.5.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">常见的值类型和引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.</span> <span class="toc-text">第三章 标识符命名注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">第四章 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.4.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.5.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.5.6.</span> <span class="toc-text">运算优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.7.</span> <span class="toc-text">键盘输入语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">第五章 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">1.6.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.6.2.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">1.6.3.</span> <span class="toc-text">for</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">遍历的两种方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break"><span class="toc-number">1.6.4.</span> <span class="toc-text">break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue"><span class="toc-number">1.6.5.</span> <span class="toc-text">continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">1.6.6.</span> <span class="toc-text">goto（一般不推荐使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">第六章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.7.2.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.7.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">1.7.6.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.7.</span> <span class="toc-text">错误处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">自定义错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.</span> <span class="toc-text">第七章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.8.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-range%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.2.</span> <span class="toc-text">for-range遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%EF%BC%88slice%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">切片（slice）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">切片的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">切片的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">切片的注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%92%8Cslice"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">string和slice</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-map"><span class="toc-number">1.9.</span> <span class="toc-text">第八章 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.1.</span> <span class="toc-text">map的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">map的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">map的增删改查操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.4.</span> <span class="toc-text">map遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.9.5.</span> <span class="toc-text">map的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%88%87%E7%89%87"><span class="toc-number">1.9.6.</span> <span class="toc-text">map切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.7.</span> <span class="toc-text">map排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.9.8.</span> <span class="toc-text">map使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%9D%A2%E5%90%91%E2%80%9D%E5%AF%B9%E8%B1%A1%E2%80%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">第九章  面向”对象“编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.10.1.</span> <span class="toc-text">面向对象编程说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A"><span class="toc-number">1.10.2.</span> <span class="toc-text">结构体：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">创建结构体变量时指定字段值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.10.3.</span> <span class="toc-text">字段&#x2F;属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.10.4.</span> <span class="toc-text">结构体的使用注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.10.5.</span> <span class="toc-text">方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">方法与函数的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.6.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.7.</span> <span class="toc-text">三大特性：封装，继承，接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BCjava%EF%BC%89%EF%BC%9A"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">封装（有点类似java）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">1.10.7.2.</span> <span class="toc-text">继承：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">1.10.7.3.</span> <span class="toc-text">接口：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%9A"><span class="toc-number">1.10.7.4.</span> <span class="toc-text">类型断言：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A%EF%BC%88os%E5%8C%85%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">第十章 文件操作：（os包）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#json-key-value"><span class="toc-number">1.11.0.1.</span> <span class="toc-text">json(key-value):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A"><span class="toc-number">1.11.0.2.</span> <span class="toc-text">go中进行单元测试：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">第十一章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine"><span class="toc-number">1.12.0.1.</span> <span class="toc-text">goroutine:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel%EF%BC%9A"><span class="toc-number">1.12.0.2.</span> <span class="toc-text">channel：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%9A"><span class="toc-number">1.12.0.3.</span> <span class="toc-text">反射：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/%E5%8C%BB%E7%96%97/" title="医疗">医疗</a><time datetime="2023-12-08T06:35:41.000Z" title="发表于 2023-12-08 14:35:41">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/%E8%BD%A6%E8%BD%BD%E7%BD%91/" title="车载网">车载网</a><time datetime="2023-12-08T06:26:51.000Z" title="发表于 2023-12-08 14:26:51">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/go%E8%AF%AD%E8%A8%80/" title="无题">无题</a><time datetime="2023-09-13T13:17:28.029Z" title="发表于 2023-09-13 21:17:28">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/12/%E5%85%B6%E4%BB%96/" title="无题">无题</a><time datetime="2023-09-12T09:40:04.343Z" title="发表于 2023-09-12 17:40:04">2023-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/11/%E5%9F%BA%E4%BA%8E%E7%BC%96%E7%A0%81%E7%9A%84%E8%AE%B8%E5%8F%AF%E9%93%BE%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/" title="基于编码的许可链数据存储方案研究">基于编码的许可链数据存储方案研究</a><time datetime="2023-09-11T14:30:29.000Z" title="发表于 2023-09-11 22:30:29">2023-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By →╋ぁ陈ぁ╋←</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>